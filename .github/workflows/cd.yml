name: Continuous Deployment (CD)

# This workflow runs automatically when code is merged to main branch
# It builds Docker images, pushes to Docker Hub, and deploys to Kubernetes

on:
  # Only run on main branch (production) or version tags
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  # Allow manual trigger
  workflow_dispatch:

# Environment variables (used throughout the workflow)
env:
  DOCKER_REGISTRY: docker.io
  BACKEND_IMAGE: arifhossaincse22/dhakacart-backend
  FRONTEND_IMAGE: arifhossaincse22/dhakacart-frontend

jobs:
  # Job 1: Build and Push Docker Images
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: Get the code
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 2: Get version from git tag or use timestamp
      - name: Get version
        id: version
        run: |
          if [ "${{ github.ref_type }}" == "tag" ]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="v$(date +%Y%m%d)-${GITHUB_SHA::8}"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
      
      # Step 3: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Step 4: Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      # Step 5: Build and push backend image
      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ steps.version.outputs.VERSION }}
            ${{ env.BACKEND_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE }}:latest
          cache-to: type=inline
          platforms: linux/amd64
      
      # Step 6: Build and push frontend image
      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:${{ steps.version.outputs.VERSION }}
            ${{ env.FRONTEND_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:latest
          cache-to: type=inline
          platforms: linux/amd64
      
      # Step 7: Output image versions for next job
      - name: Output image versions
        id: images
        run: |
          echo "backend_image=${{ env.BACKEND_IMAGE }}:${{ steps.version.outputs.VERSION }}" >> $GITHUB_OUTPUT
          echo "frontend_image=${{ env.FRONTEND_IMAGE }}:${{ steps.version.outputs.VERSION }}" >> $GITHUB_OUTPUT

  # Job 2: Deploy to Kubernetes (Optional - requires KUBECONFIG secret)
  deploy-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push
    # Removed job-level 'if' because accessing secrets here can cause errors
    
    steps:
      # Step 1: Get the code
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 2: Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
      
      # Step 3: Configure kubectl with KUBECONFIG
      - name: Configure kubectl
        id: login
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBECONFIG }}
        run: |
          if [ -z "$KUBE_CONFIG_DATA" ]; then
            echo "⚠️ KUBECONFIG secret is empty or not set."
            echo "Skipping Kubernetes deployment steps."
            echo "skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "✅ KUBECONFIG found, configuring kubectl..."
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          echo "skipped=false" >> $GITHUB_OUTPUT
      
      # Step 4: Update Kubernetes deployments (Only if not skipped)
      - name: Update Kubernetes deployments
        if: steps.login.outputs.skipped != 'true'
        run: |
          # Update backend deployment
          kubectl set image deployment/dhakacart-backend \
            backend=${{ needs.build-and-push.outputs.backend_image }} \
            -n dhakacart
          
          # Update frontend deployment
          kubectl set image deployment/dhakacart-frontend \
            frontend=${{ needs.build-and-push.outputs.frontend_image }} \
            -n dhakacart
      
      # Step 5: Wait for rollout to complete
      - name: Wait for rollout
        if: steps.login.outputs.skipped != 'true'
        run: |
          kubectl rollout status deployment/dhakacart-backend -n dhakacart --timeout=5m
          kubectl rollout status deployment/dhakacart-frontend -n dhakacart --timeout=5m
      
      # Step 6: Verify deployment
      - name: Verify deployment
        if: steps.login.outputs.skipped != 'true'
        run: |
          echo "Backend pods:"
          kubectl get pods -n dhakacart -l app=dhakacart-backend
          echo "Frontend pods:"
          kubectl get pods -n dhakacart -l app=dhakacart-frontend

  # Job 3: Health Check (Verify deployment is working)
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: always()  # Run even if previous jobs fail
    
    steps:
      # Step 1: Wait a bit for services to start
      - name: Wait for services
        run: sleep 30
      
      # Step 2: Check backend health (if deployed)
      - name: Check backend health
        run: |
          echo "Health check - Backend should be accessible"
          # curl -f http://your-backend-url/health || echo "Backend not accessible yet"
        continue-on-error: true
      
      # Step 3: Check frontend (if deployed)
      - name: Check frontend
        run: |
          echo "Health check - Frontend should be accessible"
          # curl -f http://your-frontend-url || echo "Frontend not accessible yet"
        continue-on-error: true

  # Job 4: Notification (Optional - send email/Slack on completion)
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-kubernetes]
    if: always()  # Always run, even on failure
    
    steps:
      - name: Deployment status
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment failed!"
          fi
      
      # You can add email/Slack notifications here
      # - name: Send email
      #   uses: dawidd6/action-send-mail@v3
      #   with:
      #     ...

